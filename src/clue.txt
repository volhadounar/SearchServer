____________________________

Зачем нужен класс InvertedIndex?
Обратный (или инвертированный) индекс широко применяется в реальных поисковых
системах — https://ru.wikipedia.org/wiki/Инвертированный_индекс. Идея очень проста.
Допустим, у нас есть N документов, каждый из которых содержит не более K слов, а также
поисковый запрос, состоящий из Q слов. Если каждое из Q слов поискать в каждом
документе, то это будет иметь асимптотику O(QNK) . Если же мы построим обратный индекс,
то есть для каждого слова построим список документов, в которых оно встречается, то
поисковый запрос будет обрабатываться за O(QN) . Таким образом, мы достигаем лучшей
асимптотики обработки поискового запроса.


Ускоряем подсчёт hitcount'а
По нашим замерам получилось, что медленнее всего работает подсчёт hitcount'а для
документов, а именно вот этот кусок кода:
map<size_t, size_t> docid_count;
for (const auto& word : words) {
for (const size_t docid : index.Lookup(word)) {
docid_count[docid]++;
}
}
Давайте посмотрим, какую он имеет асимптотику. Если запрос состоит из Q слов и всего у
нас имеется N документов, то асимптотика этого кода получается O((QN log N) * f(Lookup)) ,
где f(Lookup) — это асимптотика метода Lookup у класса InvertedIndex . Подумайте, как нам
уменьшить её до O(QN * f(Lookup)) , учитывая, что у N <= 50 000 и идентификаторы
документов — это целые числа от 0 до N - 1 .
Избавление от log N в асимптотике в данном случае весьма важно. По условию задачи N <=
50 000 , следовательно log N <= 16 . То есть мы можем ускорить этот цикл в 16 раз. Так как он
выполняется для каждого поискового запроса, то и обработка всех запросов может быть, в
теории, ускорена в 16 раз.

Замена map на вектор
Так как всего документов не больше 50 000, то мы можем заменить map<size_t, size_t>
docid_count на vector<size_t> , это снизит асимптотику обращения к индексу до O(QN *
f(Lookup)) . Кроме того, мы можем вынести вектор за пределы цикла for (string
current_query; getline(query_input, current_query); ) , чтобы один раз выделить под него
память, а не делать это на каждой итерации цикла.

Ускорение сортировки
После замены map'а на вектор, по нашим замерам, узким местом в обработке запросов стала
сортировка. Мы в ней выполняем сортировку всего вектора из 50 000 элементов, хотя нам
нужно только 5 наиболее релевантных документов. Можем ли мы заменить
алгоритм sort на какой-то другой стандартный алгоритм, который позволяет быстрее
находить 5 наиболее релевантных документов?

Ускорение сортировки
Для ускорения сортировки документов можно воспользоваться алгоритмом partial_sort.
Алгоритм sort позволяет найти первые пять максимумов за O(N log N) , а
алгоритм partial_sort — за O(N) .


Многопоточность
Так как метод AddQueriesStream никак не изменяет содержимое индекса, то ускорения можно
достигнуть за счёт параллельного выполнения нескольких вызовов этого метода.

Синхронизация?
Параллельные потоки, выполняющие метод AddQueriesStream , обращаются к общей области
памяти — полю index , — но не изменяют его. Нужно ли защищать обращение к индексу
мьютексом?

Синхронизация
Если бы индекс не изменялся в течение жизни объекта SearchServer , то выполнять
сихронизацию доступа к нему из метода AddQueriesStream было бы не нужно. Но
параллельно с этим методом может вызываться ещё UpdateDocumentBase , который изменяет
индекс. Поэтому поле index в классе SearchServer всё-таки надо защитить мьютексом. Для
этого удобно воспользоваться шаблоном Synchronized , который мы реализовали в одной из
задач модуля «Многопоточность».

Параллельное построение индекса
Построение индекса в методе UpdateDocumentBase занимает какое-то значительное время.
Если выполнять его под мьютексом, то параллельная обработка поисковых запросов будет
заблокирована. Поэтому лучше сначала в отдельном потоке построить новый объект
класса InvertedIndex , а потом под мьютеком лишь переместить его в
поле index класса SearchServer .